{"ast":null,"code":"import { useState, useContext } from \"react\";\nimport uniqueId from \"../../utils/uniqueId\";\nimport { initialDrivers, initialYearTasks } from \"../../utils/sampleData\";\n/*\n  I couldn't find a good library that implements time on \n  a 24 h / 7 day / 52 week discrete timescale. Popular libraries \n  like MomentJS are implemented in real world timescales. \n  For simplicity sake, I ended up just writing the way the \n  time works myself.\n */\n\nexport default function useCalendar() {\n  /* I've elected to use useState instead of useReducer because the various states \n  don't really rely on the value of another state in order to update*/\n\n  /* Time 0 is set set arbitrarily to some point in the spacetime\n  Each increment of 1 represents the passing of one hour\n  Not sure if this is the best way to keep track of time\n  Can switch to momentJS in the future\n  No use for time state right now since not using real world time\n  */\n  // const [time, setTime] = useState(0);\n  // weeks starts incrementing at 0\n  const [calendarTime, setCalendarTime] = useState(0); // state responsible for controlled input of calendar header weeks\n\n  const [weekInput, setWeekInput] = useState(calendarTime); // keep track of which drivers fall under the dispatcher each year\n  // and whether they are shown on the calendar\n  // driversSelected state keeps track of which driver is selected and shows on calendar\n\n  const [driversSelected, setDrivers] = useState(initialDrivers); // remove selected property to form driversList\n  // it will used for creating new tasks and keep track of who are all the drivers\n\n  const driversList = driversSelected.map(({\n    id,\n    name\n  }) => ({\n    id,\n    name\n  })); // tasks of the year\n\n  const [yearlyTasks, setYearlyTasks] = useState(initialYearTasks); // function ensures yearlyTasks is always sorted from earliest to latest\n  // ensures finding of conflicted schedules\n\n  const sortTasks = function (taskMap) {\n    return new Map([...taskMap.entries()].sort((a, b) => a[1].time.start - b[1].time.start));\n  };\n\n  const checkTimeConflict = function (newTask, yearlyTasks) {\n    const conflictedTasks = [];\n\n    for (const [, existingTask] of yearlyTasks) {\n      // if different drivers, pass\n      if (existingTask.driver.id !== newTask.driver.id) {\n        continue;\n      } // if same task, pass\n      // this occurs when editing task\n      else if (existingTask.id === newTask.id) {\n          continue;\n        } // check if existing task start time between new task start/end\n\n\n      if (existingTask.time.start >= newTask.time.start && existingTask.time.start < newTask.time.end) {\n        conflictedTasks.push(existingTask);\n      } // check if existing task end time between new task start/end\n      else if (existingTask.time.end > newTask.time.start && existingTask.time.end <= newTask.time.end) {\n          conflictedTasks.push(existingTask);\n        } // should leave loop when existing tasks happen after new task\n        else if (existingTask.time.start >= newTask.time.end) {\n            break;\n          }\n    }\n\n    return conflictedTasks;\n  }; // maybe refactoring this to promise based would be more readable\n\n\n  const addTask = function (task) {\n    const conflictedTasks = checkTimeConflict(task, yearlyTasks);\n\n    if (!conflictedTasks.length) {\n      setYearlyTasks(prev => {\n        const newTasksMap = new Map(prev); // if id exists, the task is edited by reusing id\n\n        const id = task.id ? task.id : uniqueId();\n        newTasksMap.set(id, { ...task,\n          id\n        });\n        return sortTasks(newTasksMap);\n      });\n    } else {\n      return conflictedTasks;\n    }\n  };\n\n  const deleteTask = function (taskId) {\n    setYearlyTasks(prev => {\n      const newTasksMap = new Map(prev);\n      newTasksMap.delete(taskId);\n      return newTasksMap;\n    });\n  };\n  /* this function is needed because when resolving conflicted tasks,\n  overriding a conflicted task means at least one task is deleted and one \n  added at the same time. By calling addTask after deleteTask, we cannot \n  ensure that the conflicted task is deleted before addTask modifies the \n  task state, therefore causing checkTimeConflict, which is called by \n  addTask, to stop any updates to the task state */\n\n\n  const addAndDeleteTask = function (taskToBeAdded, ...taskToBeDeleted) {\n    let conflictedTasks = [];\n    setYearlyTasks(prev => {\n      const newTasksMap = new Map(prev);\n      taskToBeDeleted.forEach(taskId => {\n        newTasksMap.delete(taskId);\n      });\n      const id = taskToBeAdded.id ? taskToBeAdded.id : uniqueId();\n      conflictedTasks = checkTimeConflict(taskToBeAdded, newTasksMap); // handles edge case where adjusted position after resolving conflict also causes conflict\n\n      if (!conflictedTasks.length) {\n        newTasksMap.set(id, { ...taskToBeAdded,\n          id\n        });\n        return sortTasks(newTasksMap);\n      } else {\n        // if new conflict found, return old state\n        return new Map(prev);\n      }\n    });\n    return conflictedTasks;\n  };\n\n  const toggleDriverSelected = function (driverId) {\n    setDrivers(prev => {\n      // find index of toggled driver in state array\n      const toggledDriverIndex = prev.map(driver => driver.id).indexOf(driverId); // // construct new state array where selected bool is toggled\n\n      return prev.map((driver, i) => {\n        if (i === toggledDriverIndex) {\n          return { ...driver,\n            selected: !driver.selected\n          };\n        }\n\n        return driver;\n      });\n    });\n  };\n\n  const timeRatio = {\n    hour: 1,\n    day: 24,\n    week: 168,\n    year: 8736\n  };\n\n  const convertTime = function (time, from, to) {\n    return time * (timeRatio[from] / timeRatio[to]);\n  }; // number of week into the year\n\n\n  const week = convertTime(calendarTime % timeRatio.year, \"hour\", \"week\");\n\n  const changeWeekBy = n => {\n    setCalendarTime(prev => {\n      const newWeek = prev + n * timeRatio.week; // Don't allow negative weeks\n\n      return newWeek >= 0 ? newWeek : prev;\n    });\n  }; // return which day of the week and what hour in 24hr\n\n\n  const findDayAndHourFromTime = function (time) {\n    const day = Math.floor(time % timeRatio.week / timeRatio.day);\n    const hour = time % timeRatio.day;\n    return {\n      day,\n      hour\n    };\n  }; // handles controlled input of calendar header\n\n\n  const handleOnChange = function (e) {\n    const newValue = e.target.value.trim(); // number must be between 0-51 included\n\n    const re = /^([0-9]|[1-4][0-9]|5[01])$/;\n    setWeekInput(prev => {\n      if (re.test(newValue) || newValue === \"\") {\n        return newValue;\n      } else {\n        return prev;\n      }\n    });\n  }; // change week to selected week from week input box\n\n\n  const handleWeekJump = function () {\n    const weekDifference = weekInput - week;\n    changeWeekBy(weekDifference);\n  }; // find the task of the week currently viewed\n\n\n  let weeklyTasks = Array.from(yearlyTasks.values()).filter(task => {\n    return Math.floor(convertTime(task.time.start, \"hour\", \"week\")) === week;\n  }); //transform data to indicate day and time\n\n  weeklyTasks = weeklyTasks.map(task => ({ ...task,\n    ...findDayAndHourFromTime(task.time.start),\n    duration: task.time.end - task.time.start\n  }));\n  return {\n    addTask,\n    deleteTask,\n    addAndDeleteTask,\n    changeWeekBy,\n    week,\n    weeklyTasks,\n    weekInput,\n    handleOnChange,\n    handleWeekJump,\n    driversSelected,\n    driversList,\n    toggleDriverSelected,\n    yearlyTasks\n  };\n}","map":{"version":3,"sources":["/home/momo/portfolio/roseRocket/client/src/components/Calendar/useCalendar.js"],"names":["useState","useContext","uniqueId","initialDrivers","initialYearTasks","useCalendar","calendarTime","setCalendarTime","weekInput","setWeekInput","driversSelected","setDrivers","driversList","map","id","name","yearlyTasks","setYearlyTasks","sortTasks","taskMap","Map","entries","sort","a","b","time","start","checkTimeConflict","newTask","conflictedTasks","existingTask","driver","end","push","addTask","task","length","prev","newTasksMap","set","deleteTask","taskId","delete","addAndDeleteTask","taskToBeAdded","taskToBeDeleted","forEach","toggleDriverSelected","driverId","toggledDriverIndex","indexOf","i","selected","timeRatio","hour","day","week","year","convertTime","from","to","changeWeekBy","n","newWeek","findDayAndHourFromTime","Math","floor","handleOnChange","e","newValue","target","value","trim","re","test","handleWeekJump","weekDifference","weeklyTasks","Array","values","filter","duration"],"mappings":"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","sourcesContent":["import { useState, useContext } from \"react\";\nimport uniqueId from \"../../utils/uniqueId\";\nimport { initialDrivers, initialYearTasks } from \"../../utils/sampleData\";\n/*\n  I couldn't find a good library that implements time on \n  a 24 h / 7 day / 52 week discrete timescale. Popular libraries \n  like MomentJS are implemented in real world timescales. \n  For simplicity sake, I ended up just writing the way the \n  time works myself.\n */\nexport default function useCalendar() {\n  /* I've elected to use useState instead of useReducer because the various states \n  don't really rely on the value of another state in order to update*/\n  /* Time 0 is set set arbitrarily to some point in the spacetime\n  Each increment of 1 represents the passing of one hour\n  Not sure if this is the best way to keep track of time\n  Can switch to momentJS in the future\n  No use for time state right now since not using real world time\n  */\n  // const [time, setTime] = useState(0);\n  // weeks starts incrementing at 0\n  const [calendarTime, setCalendarTime] = useState(0);\n  // state responsible for controlled input of calendar header weeks\n  const [weekInput, setWeekInput] = useState(calendarTime);\n  // keep track of which drivers fall under the dispatcher each year\n  // and whether they are shown on the calendar\n\n  // driversSelected state keeps track of which driver is selected and shows on calendar\n  const [driversSelected, setDrivers] = useState(initialDrivers);\n  // remove selected property to form driversList\n  // it will used for creating new tasks and keep track of who are all the drivers\n  const driversList = driversSelected.map(({ id, name }) => ({ id, name }));\n  // tasks of the year\n  const [yearlyTasks, setYearlyTasks] = useState(initialYearTasks);\n\n  // function ensures yearlyTasks is always sorted from earliest to latest\n  // ensures finding of conflicted schedules\n  const sortTasks = function (taskMap) {\n    return new Map(\n      [...taskMap.entries()].sort((a, b) => a[1].time.start - b[1].time.start)\n    );\n  };\n\n  const checkTimeConflict = function (newTask, yearlyTasks) {\n    const conflictedTasks = [];\n    for (const [, existingTask] of yearlyTasks) {\n      // if different drivers, pass\n\n      if (existingTask.driver.id !== newTask.driver.id) {\n        continue;\n      }\n      // if same task, pass\n      // this occurs when editing task\n      else if (existingTask.id === newTask.id) {\n        continue;\n      }\n      // check if existing task start time between new task start/end\n      if (\n        existingTask.time.start >= newTask.time.start &&\n        existingTask.time.start < newTask.time.end\n      ) {\n        conflictedTasks.push(existingTask);\n      }\n      // check if existing task end time between new task start/end\n      else if (\n        existingTask.time.end > newTask.time.start &&\n        existingTask.time.end <= newTask.time.end\n      ) {\n        conflictedTasks.push(existingTask);\n      }\n      // should leave loop when existing tasks happen after new task\n      else if (existingTask.time.start >= newTask.time.end) {\n        break;\n      }\n    }\n    return conflictedTasks;\n  };\n  // maybe refactoring this to promise based would be more readable\n  const addTask = function (task) {\n    const conflictedTasks = checkTimeConflict(task, yearlyTasks);\n    if (!conflictedTasks.length) {\n      setYearlyTasks((prev) => {\n        const newTasksMap = new Map(prev);\n        // if id exists, the task is edited by reusing id\n        const id = task.id ? task.id : uniqueId();\n        newTasksMap.set(id, { ...task, id });\n        return sortTasks(newTasksMap);\n      });\n    } else {\n      return conflictedTasks;\n    }\n  };\n\n  const deleteTask = function (taskId) {\n    setYearlyTasks((prev) => {\n      const newTasksMap = new Map(prev);\n      newTasksMap.delete(taskId);\n      return newTasksMap;\n    });\n  };\n  /* this function is needed because when resolving conflicted tasks,\n  overriding a conflicted task means at least one task is deleted and one \n  added at the same time. By calling addTask after deleteTask, we cannot \n  ensure that the conflicted task is deleted before addTask modifies the \n  task state, therefore causing checkTimeConflict, which is called by \n  addTask, to stop any updates to the task state */\n  const addAndDeleteTask = function (taskToBeAdded, ...taskToBeDeleted) {\n    let conflictedTasks = [];\n    setYearlyTasks((prev) => {\n      const newTasksMap = new Map(prev);\n      taskToBeDeleted.forEach((taskId) => {\n        newTasksMap.delete(taskId);\n      });\n      const id = taskToBeAdded.id ? taskToBeAdded.id : uniqueId();\n      conflictedTasks = checkTimeConflict(taskToBeAdded, newTasksMap);\n      // handles edge case where adjusted position after resolving conflict also causes conflict\n      if (!conflictedTasks.length) {\n        newTasksMap.set(id, { ...taskToBeAdded, id });\n        return sortTasks(newTasksMap);\n      } else {\n        // if new conflict found, return old state\n        return new Map(prev);\n      }\n    });\n    return conflictedTasks;\n  };\n\n  const toggleDriverSelected = function (driverId) {\n    setDrivers((prev) => {\n      // find index of toggled driver in state array\n      const toggledDriverIndex = prev\n        .map((driver) => driver.id)\n        .indexOf(driverId);\n      // // construct new state array where selected bool is toggled\n      return prev.map((driver, i) => {\n        if (i === toggledDriverIndex) {\n          return { ...driver, selected: !driver.selected };\n        }\n        return driver;\n      });\n    });\n  };\n  const timeRatio = {\n    hour: 1,\n    day: 24,\n    week: 168,\n    year: 8736,\n  };\n\n  const convertTime = function (time, from, to) {\n    return time * (timeRatio[from] / timeRatio[to]);\n  };\n  // number of week into the year\n  const week = convertTime(calendarTime % timeRatio.year, \"hour\", \"week\");\n\n  const changeWeekBy = (n) => {\n    setCalendarTime((prev) => {\n      const newWeek = prev + n * timeRatio.week;\n      // Don't allow negative weeks\n      return newWeek >= 0 ? newWeek : prev;\n    });\n  };\n  // return which day of the week and what hour in 24hr\n  const findDayAndHourFromTime = function (time) {\n    const day = Math.floor((time % timeRatio.week) / timeRatio.day);\n    const hour = time % timeRatio.day;\n    return { day, hour };\n  };\n\n  // handles controlled input of calendar header\n  const handleOnChange = function (e) {\n    const newValue = e.target.value.trim();\n    // number must be between 0-51 included\n    const re = /^([0-9]|[1-4][0-9]|5[01])$/;\n    setWeekInput((prev) => {\n      if (re.test(newValue) || newValue === \"\") {\n        return newValue;\n      } else {\n        return prev;\n      }\n    });\n  };\n\n  // change week to selected week from week input box\n  const handleWeekJump = function () {\n    const weekDifference = weekInput - week;\n    changeWeekBy(weekDifference);\n  };\n\n  // find the task of the week currently viewed\n  let weeklyTasks = Array.from(yearlyTasks.values()).filter((task) => {\n    return Math.floor(convertTime(task.time.start, \"hour\", \"week\")) === week;\n  });\n\n  //transform data to indicate day and time\n  weeklyTasks = weeklyTasks.map((task) => ({\n    ...task,\n    ...findDayAndHourFromTime(task.time.start),\n    duration: task.time.end - task.time.start,\n  }));\n\n  return {\n    addTask,\n    deleteTask,\n    addAndDeleteTask,\n    changeWeekBy,\n    week,\n    weeklyTasks,\n    weekInput,\n    handleOnChange,\n    handleWeekJump,\n    driversSelected,\n    driversList,\n    toggleDriverSelected,\n    yearlyTasks,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}