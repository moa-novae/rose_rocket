{"ast":null,"code":"import _toConsumableArray from\"/home/momo/portfolio/roseRocket/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _defineProperty from\"/home/momo/portfolio/roseRocket/client/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _objectSpread from\"/home/momo/portfolio/roseRocket/client/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/home/momo/portfolio/roseRocket/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState}from\"react\";import{convertTime}from\"../../../../utils/convertTime\";export default function useCreateModal(initialState,addTask,deleteTask,addAndDeleteTask,setShowModal){var _useState=useState(initialState),_useState2=_slicedToArray(_useState,2),form=_useState2[0],setForm=_useState2[1];var _useState3=useState({}),_useState4=_slicedToArray(_useState3,2),errors=_useState4[0],setError=_useState4[1];var _useState5=useState(false),_useState6=_slicedToArray(_useState5,2),showConflictOptions=_useState6[0],setShowConflictOptions=_useState6[1];var _useState7=useState([]),_useState8=_slicedToArray(_useState7,2),conflictedTasks=_useState8[0],setConflictedTasks=_useState8[1];function validateSubmit(form){var newError={};if(!form.name){newError.name=\"Name cannot be empty\";}if(!form.taskType.id){newError.taskType=\"A task type must be selected\";}if(!form.driver.id){newError.driver=\"A driver must be selected\";}if(!form.startDay||!form.startHour||!form.endHour||form.endHour<form.startHour){newError.time=\"Please enter a valid time\";}return newError;}function validateOnChange(name,newValue,oldState){var validDay=/^([0-9]|[1-8][0-9]|9[0-9]|[12][0-9]{2}|3[0-5][0-9]|36[0-3])$/;var validHour=/^([0-9]|1[0-9]|2[0-3])$/;switch(name){case\"startDay\":if(newValue===\"\"){return newValue;}// check if valid day 0 - 363\nif(validDay.test(newValue)){return newValue;}return oldState[name];case\"startHour\":case\"endHour\":if(newValue===\"\"){return newValue;}// check if valid hour 0 - 23\nif(validHour.test(newValue)){return newValue;}return oldState[name];default:return newValue;}}function handleOnChange(e){var _e$target=e.target,name=_e$target.name,value=_e$target.value;setForm(function(prev){return _objectSpread({},prev,_defineProperty({},name,validateOnChange(name,value,prev)));});}function handleDriverChange(driver){setForm(function(prev){return _objectSpread({},prev,{driver:driver});});}function handleTaskTypeChange(taskType){setForm(function(prev){return _objectSpread({},prev,{taskType:taskType});});}function transformFormToTaskShape(form){var name=form.name,description=form.description,taskType=form.taskType,driver=form.driver,startLocation=form.startLocation,endLocation=form.endLocation,startDay=form.startDay,startHour=form.startHour,endHour=form.endHour,id=form.id;var day=convertTime(startDay,\"day\",\"hour\");var startTime=day+parseInt(startHour);var endTime=day+parseInt(endHour);var task={id:id,name:name,description:description,type:taskType.id,driver:driver,location:{start:startLocation,end:endLocation},time:{start:parseInt(startTime),end:parseInt(endTime)}};return task;}function handleSubmit(){var newErrors=validateSubmit(form);if(Object.keys(newErrors).length){setError(newErrors);}else{// need to transform form state to the shape of task state in useCalendar\n// addTask return array of conflicted tasks if any\nvar _conflictedTasks=addTask(transformFormToTaskShape(form));if(_conflictedTasks===null||_conflictedTasks===void 0?void 0:_conflictedTasks.length){setConflictedTasks(_conflictedTasks);setShowConflictOptions(true);}else{// close modal if no errors in form and no conflict\nsetShowModal(false);setForm(initialState);}}}function handlePlaceAroundConflict(place){var localConflictedTasks=_toConsumableArray(conflictedTasks);var task=transformFormToTaskShape(form);var taskDuration=task.time.end-task.time.start;// every loop, a conflict free slot is proposed based on immediate conflicts\n// if there is still conflict at the new slot, repeat\nwhile(localConflictedTasks.length||task.time.start%24>task.time.end%24){if(place===\"before\"){// element at conflictedTasks[0] is the earliest conflict\ntask.time.end=localConflictedTasks[0].time.start;task.time.start=task.time.end-taskDuration;}else if(place===\"after\"){// sort task with the latest end time to index 0\ntask.time.start=localConflictedTasks.sort(function(a,b){return b.time.end-a.time.end;})[0].time.end;task.time.end=task.time.start+taskDuration;}// first parameter is task to be added, rest are to be deleted\n// the task itself need to be deleted in case of edits to stop false conflicts\n// keep checking for free space until no conflict and task not over night\nlocalConflictedTasks=addAndDeleteTask(task,task.id);}setShowModal(false);setShowConflictOptions(false);setForm(initialState);}function handleOverrideConflict(){var task=transformFormToTaskShape(form);addAndDeleteTask.apply(void 0,[task].concat(_toConsumableArray(conflictedTasks.map(function(task){return task.id;}))));setShowModal(false);setShowConflictOptions(false);setForm(initialState);}function closeConflictOptions(){setShowConflictOptions(false);}return{form:form,showConflictOptions:showConflictOptions,closeConflictOptions:closeConflictOptions,errors:errors,handleOnChange:handleOnChange,handleDriverChange:handleDriverChange,handleTaskTypeChange:handleTaskTypeChange,handleSubmit:handleSubmit,handlePlaceAroundConflict:handlePlaceAroundConflict,handleOverrideConflict:handleOverrideConflict};}","map":{"version":3,"sources":["/home/momo/portfolio/roseRocket/client/src/components/Calendar/CalendarSidebar/CreateModal/useCreateModal.js"],"names":["useState","convertTime","useCreateModal","initialState","addTask","deleteTask","addAndDeleteTask","setShowModal","form","setForm","errors","setError","showConflictOptions","setShowConflictOptions","conflictedTasks","setConflictedTasks","validateSubmit","newError","name","taskType","id","driver","startDay","startHour","endHour","time","validateOnChange","newValue","oldState","validDay","validHour","test","handleOnChange","e","target","value","prev","handleDriverChange","handleTaskTypeChange","transformFormToTaskShape","description","startLocation","endLocation","day","startTime","parseInt","endTime","task","type","location","start","end","handleSubmit","newErrors","Object","keys","length","handlePlaceAroundConflict","place","localConflictedTasks","taskDuration","sort","a","b","handleOverrideConflict","map","closeConflictOptions"],"mappings":"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","sourcesContent":["import { useState } from \"react\";\nimport { convertTime } from \"../../../../utils/convertTime\";\nexport default function useCreateModal(\n  initialState,\n  addTask,\n  deleteTask,\n  addAndDeleteTask,\n  setShowModal\n) {\n  const [form, setForm] = useState(initialState);\n  const [errors, setError] = useState({});\n  const [showConflictOptions, setShowConflictOptions] = useState(false);\n  const [conflictedTasks, setConflictedTasks] = useState([]);\n  function validateSubmit(form) {\n    let newError = {};\n    if (!form.name) {\n      newError.name = \"Name cannot be empty\";\n    }\n    if (!form.taskType.id) {\n      newError.taskType = \"A task type must be selected\";\n    }\n    if (!form.driver.id) {\n      newError.driver = \"A driver must be selected\";\n    }\n    if (\n      !form.startDay ||\n      !form.startHour ||\n      !form.endHour ||\n      form.endHour < form.startHour\n    ) {\n      newError.time = \"Please enter a valid time\";\n    }\n    return newError;\n  }\n\n  function validateOnChange(name, newValue, oldState) {\n    const validDay = /^([0-9]|[1-8][0-9]|9[0-9]|[12][0-9]{2}|3[0-5][0-9]|36[0-3])$/;\n    const validHour = /^([0-9]|1[0-9]|2[0-3])$/;\n    switch (name) {\n      case \"startDay\":\n        if (newValue === \"\") {\n          return newValue;\n        }\n        // check if valid day 0 - 363\n        if (validDay.test(newValue)) {\n          return newValue;\n        }\n        return oldState[name];\n      case \"startHour\":\n      case \"endHour\":\n        if (newValue === \"\") {\n          return newValue;\n        }\n        // check if valid hour 0 - 23\n        if (validHour.test(newValue)) {\n          return newValue;\n        }\n        return oldState[name];\n\n      default:\n        return newValue;\n    }\n  }\n  function handleOnChange(e) {\n    const { name, value } = e.target;\n    setForm((prev) => ({\n      ...prev,\n      [name]: validateOnChange(name, value, prev),\n    }));\n  }\n  function handleDriverChange(driver) {\n    setForm((prev) => ({ ...prev, driver }));\n  }\n  function handleTaskTypeChange(taskType) {\n    setForm((prev) => ({ ...prev, taskType }));\n  }\n\n  function transformFormToTaskShape(form) {\n    const {\n      name,\n      description,\n      taskType,\n      driver,\n      startLocation,\n      endLocation,\n      startDay,\n      startHour,\n      endHour,\n      id,\n    } = form;\n    const day = convertTime(startDay, \"day\", \"hour\");\n    const startTime = day + parseInt(startHour);\n    const endTime = day + parseInt(endHour);\n    const task = {\n      id,\n      name: name,\n      description,\n      type: taskType.id,\n      driver,\n      location: { start: startLocation, end: endLocation },\n      time: { start: parseInt(startTime), end: parseInt(endTime) },\n    };\n    return task;\n  }\n\n  function handleSubmit() {\n    const newErrors = validateSubmit(form);\n    if (Object.keys(newErrors).length) {\n      setError(newErrors);\n    } else {\n      // need to transform form state to the shape of task state in useCalendar\n      // addTask return array of conflicted tasks if any\n      const conflictedTasks = addTask(transformFormToTaskShape(form));\n      if (conflictedTasks?.length) {\n        setConflictedTasks(conflictedTasks);\n        setShowConflictOptions(true);\n      } else {\n        // close modal if no errors in form and no conflict\n        setShowModal(false);\n        setForm(initialState);\n      }\n    }\n  }\n\n  function handlePlaceAroundConflict(place) {\n    let localConflictedTasks = [...conflictedTasks];\n    let task = transformFormToTaskShape(form);\n    const taskDuration = task.time.end - task.time.start;\n    // every loop, a conflict free slot is proposed based on immediate conflicts\n    // if there is still conflict at the new slot, repeat\n    while (\n      localConflictedTasks.length ||\n      task.time.start % 24 > task.time.end % 24\n    ) {\n      if (place === \"before\") {\n        // element at conflictedTasks[0] is the earliest conflict\n        task.time.end = localConflictedTasks[0].time.start;\n        task.time.start = task.time.end - taskDuration;\n      } else if (place === \"after\") {\n        // sort task with the latest end time to index 0\n        task.time.start = localConflictedTasks.sort(\n          (a, b) => b.time.end - a.time.end\n        )[0].time.end;\n        task.time.end = task.time.start + taskDuration;\n      }\n\n      // first parameter is task to be added, rest are to be deleted\n      // the task itself need to be deleted in case of edits to stop false conflicts\n      // keep checking for free space until no conflict and task not over night\n      localConflictedTasks = addAndDeleteTask(task, task.id);\n    }\n    setShowModal(false);\n    setShowConflictOptions(false);\n    setForm(initialState);\n  }\n\n  function handleOverrideConflict() {\n    const task = transformFormToTaskShape(form);\n    addAndDeleteTask(task, ...conflictedTasks.map((task) => task.id));\n    setShowModal(false);\n    setShowConflictOptions(false);\n    setForm(initialState);\n  }\n  function closeConflictOptions() {\n    setShowConflictOptions(false);\n  }\n  return {\n    form,\n    showConflictOptions,\n    closeConflictOptions,\n    errors,\n    handleOnChange,\n    handleDriverChange,\n    handleTaskTypeChange,\n    handleSubmit,\n    handlePlaceAroundConflict,\n    handleOverrideConflict,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}