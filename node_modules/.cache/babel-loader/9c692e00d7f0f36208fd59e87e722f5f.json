{"ast":null,"code":"import _objectSpread from\"/home/momo/portfolio/roseRocket/client/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _createForOfIteratorHelper from\"/home/momo/portfolio/roseRocket/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import _toConsumableArray from\"/home/momo/portfolio/roseRocket/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _slicedToArray from\"/home/momo/portfolio/roseRocket/client/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState}from\"react\";import uniqueId from\"../../utils/uniqueId\";import{initialDrivers,initialYearTasks}from\"../../utils/sampleData\";/*\n  I couldn't find a good library that implements time on \n  a 24 h / 7 day / 52 week discrete timescale. Popular libraries \n  like MomentJS are implemented in real world timescales. \n  For simplicity sake, I ended up just writing the way the \n  time works myself.\n */export default function useCalendar(){/* I've elected to use useState instead of useReducer because the various states \n  don't really rely on the value of another state in order to update*/ /* Time 0 is set set arbitrarily to some point in the spacetime\n  Each increment of 1 represents the passing of one hour\n  Not sure if this is the best way to keep track of time\n  Can switch to momentJS in the future\n  No use for time state right now since not using real world time\n  */ // const [time, setTime] = useState(0);\n// weeks starts incrementing at 0\nvar _useState=useState(0),_useState2=_slicedToArray(_useState,2),calendarTime=_useState2[0],setCalendarTime=_useState2[1];// state responsible for controlled input of calendar header weeks\nvar _useState3=useState(calendarTime),_useState4=_slicedToArray(_useState3,2),weekInput=_useState4[0],setWeekInput=_useState4[1];// keep track of which drivers fall under the dispatcher each year\n// and whether they are shown on the calendar\n// driversSelected state keeps track of which driver is selected and shows on calendar\nvar _useState5=useState(initialDrivers),_useState6=_slicedToArray(_useState5,2),driversSelected=_useState6[0],setDrivers=_useState6[1];// remove selected property to form driversList\n// it will used for creating new tasks and keep track of who are all the drivers\nvar driversList=driversSelected.map(function(_ref){var id=_ref.id,name=_ref.name,colour=_ref.colour;return{id:id,name:name,colour:colour};});// tasks of the year\nvar _useState7=useState(initialYearTasks),_useState8=_slicedToArray(_useState7,2),yearlyTasks=_useState8[0],setYearlyTasks=_useState8[1];// function ensures yearlyTasks is always sorted from earliest to latest\n// ensures finding of conflicted schedules\nvar sortTasks=function sortTasks(taskMap){return new Map(_toConsumableArray(taskMap.entries()).sort(function(a,b){return a[1].time.start-b[1].time.start;}));};var checkTimeConflict=function checkTimeConflict(newTask,yearlyTasks){var conflictedTasks=[];var _iterator=_createForOfIteratorHelper(yearlyTasks),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var _step$value=_slicedToArray(_step.value,2),existingTask=_step$value[1];// if different drivers, pass\nif(existingTask.driver.id!==newTask.driver.id){continue;}// if same task, pass\n// this occurs when editing task\nelse if(existingTask.id===newTask.id){continue;}// check if existing task start time between new task start/end\nif(existingTask.time.start>=newTask.time.start&&existingTask.time.start<newTask.time.end){conflictedTasks.push(existingTask);}// check if existing task end time between new task start/end\nelse if(existingTask.time.end>newTask.time.start&&existingTask.time.end<=newTask.time.end){conflictedTasks.push(existingTask);}// should leave loop when existing tasks happen after new task\nelse if(existingTask.time.start>=newTask.time.end){break;}}}catch(err){_iterator.e(err);}finally{_iterator.f();}return conflictedTasks;};// maybe refactoring this to promise based would be more readable\nvar addTask=function addTask(task){var conflictedTasks=checkTimeConflict(task,yearlyTasks);if(!conflictedTasks.length){setYearlyTasks(function(prev){var newTasksMap=new Map(prev);// if id exists, the task is edited by reusing id\nvar id=task.id?task.id:uniqueId();newTasksMap.set(id,_objectSpread({},task,{id:id}));return sortTasks(newTasksMap);});}else{return conflictedTasks;}};var deleteTask=function deleteTask(taskId){setYearlyTasks(function(prev){var newTasksMap=new Map(prev);newTasksMap.delete(taskId);return newTasksMap;});};/* this function is needed because when resolving conflicted tasks,\n  overriding a conflicted task means at least one task is deleted and one \n  added at the same time. By calling addTask after deleteTask, we cannot \n  ensure that the conflicted task is deleted before addTask modifies the \n  task state, therefore causing checkTimeConflict, which is called by \n  addTask, to stop any updates to the task state */var addAndDeleteTask=function addAndDeleteTask(taskToBeAdded){for(var _len=arguments.length,taskToBeDeleted=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){taskToBeDeleted[_key-1]=arguments[_key];}var conflictedTasks=[];setYearlyTasks(function(prev){var newTasksMap=new Map(prev);taskToBeDeleted.forEach(function(taskId){newTasksMap.delete(taskId);});var id=taskToBeAdded.id?taskToBeAdded.id:uniqueId();conflictedTasks=checkTimeConflict(taskToBeAdded,newTasksMap);// handles edge case where adjusted position after resolving conflict also causes conflict\nif(!conflictedTasks.length){newTasksMap.set(id,_objectSpread({},taskToBeAdded,{id:id}));return sortTasks(newTasksMap);}else{// if new conflict found, return old state\nreturn new Map(prev);}});return conflictedTasks;};var toggleDriverSelected=function toggleDriverSelected(driverId){setDrivers(function(prev){// find index of toggled driver in state array\nvar toggledDriverIndex=prev.map(function(driver){return driver.id;}).indexOf(driverId);// // construct new state array where selected bool is toggled\nreturn prev.map(function(driver,i){if(i===toggledDriverIndex){return _objectSpread({},driver,{selected:!driver.selected});}return driver;});});};var timeRatio={hour:1,day:24,week:168,year:8736};var convertTime=function convertTime(time,from,to){return time*(timeRatio[from]/timeRatio[to]);};// number of week into the year\nvar week=convertTime(calendarTime%timeRatio.year,\"hour\",\"week\");var changeWeekBy=function changeWeekBy(n){setCalendarTime(function(prev){var newWeek=prev+n*timeRatio.week;// Don't allow negative weeks\nreturn newWeek>=0?newWeek:prev;});};// return which day of the week and what hour in 24hr\nvar findDayAndHourFromTime=function findDayAndHourFromTime(time){var day=Math.floor(time%timeRatio.week/timeRatio.day);var hour=time%timeRatio.day;return{day:day,hour:hour};};// handles controlled input of calendar header\nvar handleOnChange=function handleOnChange(e){var newValue=e.target.value.trim();// number must be between 0-51 included\nvar re=/^([0-9]|[1-4][0-9]|5[01])$/;setWeekInput(function(prev){if(re.test(newValue)||newValue===\"\"){return newValue;}else{return prev;}});};// change week to selected week from week input box\nvar handleWeekJump=function handleWeekJump(){var weekDifference=weekInput-week;changeWeekBy(weekDifference);};// find the task of the week currently viewed\nvar weeklyTasks=Array.from(yearlyTasks.values()).filter(function(task){return Math.floor(convertTime(task.time.start,\"hour\",\"week\"))===week;});//transform data to indicate day and time\nweeklyTasks=weeklyTasks.map(function(task){return _objectSpread({},task,{},findDayAndHourFromTime(task.time.start),{duration:task.time.end-task.time.start});});return{addTask:addTask,addAndDeleteTask:addAndDeleteTask,deleteTask:deleteTask,changeWeekBy:changeWeekBy,week:week,weeklyTasks:weeklyTasks,weekInput:weekInput,handleOnChange:handleOnChange,handleWeekJump:handleWeekJump,driversSelected:driversSelected,driversList:driversList,toggleDriverSelected:toggleDriverSelected,yearlyTasks:yearlyTasks};}","map":{"version":3,"sources":["/home/momo/portfolio/roseRocket/client/src/components/Calendar/useCalendar.js"],"names":["useState","uniqueId","initialDrivers","initialYearTasks","useCalendar","calendarTime","setCalendarTime","weekInput","setWeekInput","driversSelected","setDrivers","driversList","map","id","name","colour","yearlyTasks","setYearlyTasks","sortTasks","taskMap","Map","entries","sort","a","b","time","start","checkTimeConflict","newTask","conflictedTasks","existingTask","driver","end","push","addTask","task","length","prev","newTasksMap","set","deleteTask","taskId","delete","addAndDeleteTask","taskToBeAdded","taskToBeDeleted","forEach","toggleDriverSelected","driverId","toggledDriverIndex","indexOf","i","selected","timeRatio","hour","day","week","year","convertTime","from","to","changeWeekBy","n","newWeek","findDayAndHourFromTime","Math","floor","handleOnChange","e","newValue","target","value","trim","re","test","handleWeekJump","weekDifference","weeklyTasks","Array","values","filter","duration"],"mappings":"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","sourcesContent":["import { useState } from \"react\";\nimport uniqueId from \"../../utils/uniqueId\";\nimport { initialDrivers, initialYearTasks } from \"../../utils/sampleData\";\n/*\n  I couldn't find a good library that implements time on \n  a 24 h / 7 day / 52 week discrete timescale. Popular libraries \n  like MomentJS are implemented in real world timescales. \n  For simplicity sake, I ended up just writing the way the \n  time works myself.\n */\nexport default function useCalendar() {\n  /* I've elected to use useState instead of useReducer because the various states \n  don't really rely on the value of another state in order to update*/\n  /* Time 0 is set set arbitrarily to some point in the spacetime\n  Each increment of 1 represents the passing of one hour\n  Not sure if this is the best way to keep track of time\n  Can switch to momentJS in the future\n  No use for time state right now since not using real world time\n  */\n  // const [time, setTime] = useState(0);\n  // weeks starts incrementing at 0\n  const [calendarTime, setCalendarTime] = useState(0);\n  // state responsible for controlled input of calendar header weeks\n  const [weekInput, setWeekInput] = useState(calendarTime);\n  // keep track of which drivers fall under the dispatcher each year\n  // and whether they are shown on the calendar\n\n  // driversSelected state keeps track of which driver is selected and shows on calendar\n  const [driversSelected, setDrivers] = useState(initialDrivers);\n  // remove selected property to form driversList\n  // it will used for creating new tasks and keep track of who are all the drivers\n  const driversList = driversSelected.map(({ id, name, colour }) => ({\n    id,\n    name,\n    colour,\n  }));\n  // tasks of the year\n  const [yearlyTasks, setYearlyTasks] = useState(initialYearTasks);\n\n  // function ensures yearlyTasks is always sorted from earliest to latest\n  // ensures finding of conflicted schedules\n  const sortTasks = function (taskMap) {\n    return new Map(\n      [...taskMap.entries()].sort((a, b) => a[1].time.start - b[1].time.start)\n    );\n  };\n\n  const checkTimeConflict = function (newTask, yearlyTasks) {\n    const conflictedTasks = [];\n    for (const [, existingTask] of yearlyTasks) {\n      // if different drivers, pass\n\n      if (existingTask.driver.id !== newTask.driver.id) {\n        continue;\n      }\n      // if same task, pass\n      // this occurs when editing task\n      else if (existingTask.id === newTask.id) {\n        continue;\n      }\n      // check if existing task start time between new task start/end\n      if (\n        existingTask.time.start >= newTask.time.start &&\n        existingTask.time.start < newTask.time.end\n      ) {\n        conflictedTasks.push(existingTask);\n      }\n      // check if existing task end time between new task start/end\n      else if (\n        existingTask.time.end > newTask.time.start &&\n        existingTask.time.end <= newTask.time.end\n      ) {\n        conflictedTasks.push(existingTask);\n      }\n      // should leave loop when existing tasks happen after new task\n      else if (existingTask.time.start >= newTask.time.end) {\n        break;\n      }\n    }\n    return conflictedTasks;\n  };\n  // maybe refactoring this to promise based would be more readable\n  const addTask = function (task) {\n    const conflictedTasks = checkTimeConflict(task, yearlyTasks);\n    if (!conflictedTasks.length) {\n      setYearlyTasks((prev) => {\n        const newTasksMap = new Map(prev);\n        // if id exists, the task is edited by reusing id\n        const id = task.id ? task.id : uniqueId();\n        newTasksMap.set(id, { ...task, id });\n        return sortTasks(newTasksMap);\n      });\n    } else {\n      return conflictedTasks;\n    }\n  };\n\n  const deleteTask = function (taskId) {\n    setYearlyTasks((prev) => {\n      const newTasksMap = new Map(prev);\n      newTasksMap.delete(taskId);\n      return newTasksMap;\n    });\n  };\n  /* this function is needed because when resolving conflicted tasks,\n  overriding a conflicted task means at least one task is deleted and one \n  added at the same time. By calling addTask after deleteTask, we cannot \n  ensure that the conflicted task is deleted before addTask modifies the \n  task state, therefore causing checkTimeConflict, which is called by \n  addTask, to stop any updates to the task state */\n  const addAndDeleteTask = function (taskToBeAdded, ...taskToBeDeleted) {\n    let conflictedTasks = [];\n    setYearlyTasks((prev) => {\n      const newTasksMap = new Map(prev);\n      taskToBeDeleted.forEach((taskId) => {\n        newTasksMap.delete(taskId);\n      });\n      const id = taskToBeAdded.id ? taskToBeAdded.id : uniqueId();\n      conflictedTasks = checkTimeConflict(taskToBeAdded, newTasksMap);\n      // handles edge case where adjusted position after resolving conflict also causes conflict\n      if (!conflictedTasks.length) {\n        newTasksMap.set(id, { ...taskToBeAdded, id });\n        return sortTasks(newTasksMap);\n      } else {\n        // if new conflict found, return old state\n        return new Map(prev);\n      }\n    });\n    return conflictedTasks;\n  };\n\n  const toggleDriverSelected = function (driverId) {\n    setDrivers((prev) => {\n      // find index of toggled driver in state array\n      const toggledDriverIndex = prev\n        .map((driver) => driver.id)\n        .indexOf(driverId);\n      // // construct new state array where selected bool is toggled\n      return prev.map((driver, i) => {\n        if (i === toggledDriverIndex) {\n          return { ...driver, selected: !driver.selected };\n        }\n        return driver;\n      });\n    });\n  };\n  const timeRatio = {\n    hour: 1,\n    day: 24,\n    week: 168,\n    year: 8736,\n  };\n\n  const convertTime = function (time, from, to) {\n    return time * (timeRatio[from] / timeRatio[to]);\n  };\n  // number of week into the year\n  const week = convertTime(calendarTime % timeRatio.year, \"hour\", \"week\");\n\n  const changeWeekBy = (n) => {\n    setCalendarTime((prev) => {\n      const newWeek = prev + n * timeRatio.week;\n      // Don't allow negative weeks\n      return newWeek >= 0 ? newWeek : prev;\n    });\n  };\n  // return which day of the week and what hour in 24hr\n  const findDayAndHourFromTime = function (time) {\n    const day = Math.floor((time % timeRatio.week) / timeRatio.day);\n    const hour = time % timeRatio.day;\n    return { day, hour };\n  };\n\n  // handles controlled input of calendar header\n  const handleOnChange = function (e) {\n    const newValue = e.target.value.trim();\n    // number must be between 0-51 included\n    const re = /^([0-9]|[1-4][0-9]|5[01])$/;\n    setWeekInput((prev) => {\n      if (re.test(newValue) || newValue === \"\") {\n        return newValue;\n      } else {\n        return prev;\n      }\n    });\n  };\n\n  // change week to selected week from week input box\n  const handleWeekJump = function () {\n    const weekDifference = weekInput - week;\n    changeWeekBy(weekDifference);\n  };\n\n  // find the task of the week currently viewed\n  let weeklyTasks = Array.from(yearlyTasks.values()).filter((task) => {\n    return Math.floor(convertTime(task.time.start, \"hour\", \"week\")) === week;\n  });\n\n  //transform data to indicate day and time\n  weeklyTasks = weeklyTasks.map((task) => ({\n    ...task,\n    ...findDayAndHourFromTime(task.time.start),\n    duration: task.time.end - task.time.start,\n  }));\n\n  return {\n    addTask,\n    addAndDeleteTask,\n    deleteTask,\n    changeWeekBy,\n    week,\n    weeklyTasks,\n    weekInput,\n    handleOnChange,\n    handleWeekJump,\n    driversSelected,\n    driversList,\n    toggleDriverSelected,\n    yearlyTasks,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}