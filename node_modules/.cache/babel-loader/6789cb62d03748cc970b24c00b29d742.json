{"ast":null,"code":"import { useState } from \"react\";\nimport { convertTime } from \"../../../../utils/convertTime\";\nexport default function useCreateModal(initialState, addTask, deleteTask, addAndDeleteTask, setShowModal) {\n  const [form, setForm] = useState(initialState);\n  const [errors, setError] = useState({});\n  const [showConflictOptions, setShowConflictOptions] = useState(false);\n  const [conflictedTasks, setConflictedTasks] = useState([]);\n\n  function validateSubmit(form) {\n    let newError = {};\n\n    if (!form.name) {\n      newError.name = \"Name cannot be empty\";\n    }\n\n    if (!form.taskType.id) {\n      newError.taskType = \"A task type must be selected\";\n    }\n\n    if (!form.driver.id) {\n      newError.driver = \"A driver must be selected\";\n    }\n\n    if (!form.startDay || !form.startHour || !form.endHour) {\n      newError.time = \"Please enter a complete time\";\n    }\n\n    return newError;\n  }\n\n  function validateOnChange(name, newValue, oldState) {\n    const validDay = /^([0-9]|[1-8][0-9]|9[0-9]|[12][0-9]{2}|3[0-5][0-9]|36[0-3])$/;\n    const validHour = /^([0-9]|1[0-9]|2[0-3])$/;\n\n    switch (name) {\n      case \"startDay\":\n        if (newValue === \"\") {\n          return newValue;\n        } // check if valid day 0 - 363\n\n\n        if (validDay.test(newValue)) {\n          return newValue;\n        }\n\n        return oldState[name];\n\n      case \"startHour\":\n        if (newValue === \"\") {\n          return newValue;\n        } // check if valid hour 0 - 23\n\n\n        if (validHour.test(newValue)) {\n          // check if startHour less than endHour\n          if (parseInt(newValue) < parseInt(oldState.endHour) || !oldState.endHour) {\n            return newValue;\n          }\n        }\n\n        return oldState[name];\n\n      case \"endHour\":\n        if (newValue === \"\") {\n          return newValue;\n        } // check if valid hour 0 - 23\n\n\n        if (validHour.test(newValue)) {\n          // check if endHour less than startHour\n          if (parseInt(newValue) > parseInt(oldState.startHour) || !oldState.startHour) {\n            return newValue;\n          }\n        }\n\n        return oldState[name];\n\n      default:\n        return newValue;\n    }\n  }\n\n  function handleOnChange(e) {\n    const {\n      name,\n      value\n    } = e.target;\n    setForm(prev => ({ ...prev,\n      [name]: validateOnChange(name, value, prev)\n    }));\n  }\n\n  function handleDriverChange(driver) {\n    setForm(prev => ({ ...prev,\n      driver\n    }));\n  }\n\n  function handleTaskTypeChange(taskType) {\n    setForm(prev => ({ ...prev,\n      taskType\n    }));\n  }\n\n  function transformFormToTaskShape(form) {\n    const {\n      name,\n      description,\n      taskType,\n      driver,\n      startLocation,\n      endLocation,\n      startDay,\n      startHour,\n      endHour,\n      id\n    } = form;\n    const day = convertTime(startDay, \"day\", \"hour\");\n    const startTime = day + parseInt(startHour);\n    const endTime = day + parseInt(endHour);\n    const task = {\n      id,\n      name: name,\n      description,\n      type: taskType.id,\n      driver,\n      location: {\n        start: startLocation,\n        end: endLocation\n      },\n      time: {\n        start: parseInt(startTime),\n        end: parseInt(endTime)\n      }\n    };\n    return task;\n  }\n\n  function handleSubmit() {\n    const newErrors = validateSubmit(form);\n\n    if (Object.keys(newErrors).length) {\n      setError(newErrors);\n    } else {\n      // need to transform form state to the shape of task state in useCalendar\n      // addTask return array of conflicted tasks if any\n      const conflictedTasks = addTask(transformFormToTaskShape(form));\n\n      if (conflictedTasks === null || conflictedTasks === void 0 ? void 0 : conflictedTasks.length) {\n        setConflictedTasks(conflictedTasks);\n        setShowConflictOptions(true);\n      } else {\n        // close modal if no errors in form and no conflict\n        setShowModal(false);\n        setForm(initialState);\n      }\n    }\n  }\n\n  function handlePlaceAroundConflict(place) {\n    let localConflictedTasks = [...conflictedTasks];\n    let task = transformFormToTaskShape(form);\n    const taskDuration = task.time.end - task.time.start;\n\n    while (localConflictedTasks.length || task.time.start % 24 > task.time.end % 24) {\n      if (place === \"before\") {\n        // element at conflictedTasks[0] is the earliest conflict\n        task.time.end = localConflictedTasks[0].time.start;\n        task.time.start = task.time.end - taskDuration;\n      } else if (place === \"after\") {\n        // sort task with the latest end time to index 0\n        task.time.start = localConflictedTasks.sort((a, b) => b.time.end - a.time.end)[0].time.end;\n        task.time.end = task.time.start + taskDuration;\n      } // first parameter is task to be added, rest are to be deleted\n      // the task itself need to be deleted in case of edits to stop false conflicts\n      // keep checking for free space until no conflict and task not over night\n\n\n      localConflictedTasks = addAndDeleteTask(task, task.id);\n    }\n\n    setShowModal(false);\n    setShowConflictOptions(false);\n    setForm(initialState);\n  }\n\n  function handleOverrideConflict() {\n    const task = transformFormToTaskShape(form);\n    addAndDeleteTask(task, ...conflictedTasks.map(task => task.id));\n    setShowModal(false);\n    setShowConflictOptions(false);\n    setForm(initialState);\n  }\n\n  function closeConflictOptions() {\n    setShowConflictOptions(false);\n  }\n\n  return {\n    form,\n    showConflictOptions,\n    closeConflictOptions,\n    errors,\n    handleOnChange,\n    handleDriverChange,\n    handleTaskTypeChange,\n    handleSubmit,\n    handlePlaceAroundConflict,\n    handleOverrideConflict\n  };\n}","map":{"version":3,"sources":["/home/momo/portfolio/roseRocket/client/src/components/Calendar/CalendarSidebar/CreateModal/useCreateModal.js"],"names":["useState","convertTime","useCreateModal","initialState","addTask","deleteTask","addAndDeleteTask","setShowModal","form","setForm","errors","setError","showConflictOptions","setShowConflictOptions","conflictedTasks","setConflictedTasks","validateSubmit","newError","name","taskType","id","driver","startDay","startHour","endHour","time","validateOnChange","newValue","oldState","validDay","validHour","test","parseInt","handleOnChange","e","value","target","prev","handleDriverChange","handleTaskTypeChange","transformFormToTaskShape","description","startLocation","endLocation","day","startTime","endTime","task","type","location","start","end","handleSubmit","newErrors","Object","keys","length","handlePlaceAroundConflict","place","localConflictedTasks","taskDuration","sort","a","b","handleOverrideConflict","map","closeConflictOptions"],"mappings":"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","sourcesContent":["import { useState } from \"react\";\nimport { convertTime } from \"../../../../utils/convertTime\";\nexport default function useCreateModal(\n  initialState,\n  addTask,\n  deleteTask,\n  addAndDeleteTask,\n  setShowModal\n) {\n  const [form, setForm] = useState(initialState);\n  const [errors, setError] = useState({});\n  const [showConflictOptions, setShowConflictOptions] = useState(false);\n  const [conflictedTasks, setConflictedTasks] = useState([]);\n  function validateSubmit(form) {\n    let newError = {};\n    if (!form.name) {\n      newError.name = \"Name cannot be empty\";\n    }\n    if (!form.taskType.id) {\n      newError.taskType = \"A task type must be selected\";\n    }\n    if (!form.driver.id) {\n      newError.driver = \"A driver must be selected\";\n    }\n    if (!form.startDay || !form.startHour || !form.endHour) {\n      newError.time = \"Please enter a complete time\";\n    }\n    return newError;\n  }\n\n  function validateOnChange(name, newValue, oldState) {\n    const validDay = /^([0-9]|[1-8][0-9]|9[0-9]|[12][0-9]{2}|3[0-5][0-9]|36[0-3])$/;\n    const validHour = /^([0-9]|1[0-9]|2[0-3])$/;\n    switch (name) {\n      case \"startDay\":\n        if (newValue === \"\") {\n          return newValue;\n        }\n        // check if valid day 0 - 363\n        if (validDay.test(newValue)) {\n          return newValue;\n        }\n        return oldState[name];\n      case \"startHour\":\n        if (newValue === \"\") {\n          return newValue;\n        }\n        // check if valid hour 0 - 23\n        if (validHour.test(newValue)) {\n          // check if startHour less than endHour\n          if (\n            parseInt(newValue) < parseInt(oldState.endHour) ||\n            !oldState.endHour\n          ) {\n            return newValue;\n          }\n        }\n        return oldState[name];\n      case \"endHour\":\n        if (newValue === \"\") {\n          return newValue;\n        }\n        // check if valid hour 0 - 23\n        if (validHour.test(newValue)) {\n          // check if endHour less than startHour\n          if (\n            parseInt(newValue) > parseInt(oldState.startHour) ||\n            !oldState.startHour\n          ) {\n            return newValue;\n          }\n        }\n        return oldState[name];\n      default:\n        return newValue;\n    }\n  }\n  function handleOnChange(e) {\n    const { name, value } = e.target;\n    setForm((prev) => ({\n      ...prev,\n      [name]: validateOnChange(name, value, prev),\n    }));\n  }\n  function handleDriverChange(driver) {\n    setForm((prev) => ({ ...prev, driver }));\n  }\n  function handleTaskTypeChange(taskType) {\n    setForm((prev) => ({ ...prev, taskType }));\n  }\n\n  function transformFormToTaskShape(form) {\n    const {\n      name,\n      description,\n      taskType,\n      driver,\n      startLocation,\n      endLocation,\n      startDay,\n      startHour,\n      endHour,\n      id,\n    } = form;\n    const day = convertTime(startDay, \"day\", \"hour\");\n    const startTime = day + parseInt(startHour);\n    const endTime = day + parseInt(endHour);\n    const task = {\n      id,\n      name: name,\n      description,\n      type: taskType.id,\n      driver,\n      location: { start: startLocation, end: endLocation },\n      time: { start: parseInt(startTime), end: parseInt(endTime) },\n    };\n    return task;\n  }\n\n  function handleSubmit() {\n    const newErrors = validateSubmit(form);\n    if (Object.keys(newErrors).length) {\n      setError(newErrors);\n    } else {\n      // need to transform form state to the shape of task state in useCalendar\n      // addTask return array of conflicted tasks if any\n      const conflictedTasks = addTask(transformFormToTaskShape(form));\n      if (conflictedTasks?.length) {\n        setConflictedTasks(conflictedTasks);\n        setShowConflictOptions(true);\n      } else {\n        // close modal if no errors in form and no conflict\n        setShowModal(false);\n        setForm(initialState);\n      }\n    }\n  }\n\n  function handlePlaceAroundConflict(place) {\n    let localConflictedTasks = [...conflictedTasks];\n    let task = transformFormToTaskShape(form);\n    const taskDuration = task.time.end - task.time.start;\n    while (\n      localConflictedTasks.length ||\n      task.time.start % 24 > task.time.end % 24\n    ) {\n      if (place === \"before\") {\n        // element at conflictedTasks[0] is the earliest conflict\n        task.time.end = localConflictedTasks[0].time.start;\n        task.time.start = task.time.end - taskDuration;\n      } else if (place === \"after\") {\n        // sort task with the latest end time to index 0\n        task.time.start = localConflictedTasks.sort(\n          (a, b) => b.time.end - a.time.end\n        )[0].time.end;\n        task.time.end = task.time.start + taskDuration;\n      }\n\n      // first parameter is task to be added, rest are to be deleted\n      // the task itself need to be deleted in case of edits to stop false conflicts\n      // keep checking for free space until no conflict and task not over night\n      localConflictedTasks = addAndDeleteTask(task, task.id);\n    }\n    setShowModal(false);\n    setShowConflictOptions(false);\n    setForm(initialState);\n  }\n\n  function handleOverrideConflict() {\n    const task = transformFormToTaskShape(form);\n    addAndDeleteTask(task, ...conflictedTasks.map((task) => task.id));\n    setShowModal(false);\n    setShowConflictOptions(false);\n    setForm(initialState);\n  }\n  function closeConflictOptions() {\n    setShowConflictOptions(false);\n  }\n  return {\n    form,\n    showConflictOptions,\n    closeConflictOptions,\n    errors,\n    handleOnChange,\n    handleDriverChange,\n    handleTaskTypeChange,\n    handleSubmit,\n    handlePlaceAroundConflict,\n    handleOverrideConflict,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}